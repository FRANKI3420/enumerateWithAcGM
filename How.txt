How

以前，作ったグラフ列挙アルゴリズムの簡単な疑似コードを書いてみました．
> （Javaのプログラムを読み直したわけではなく，たぶんこうだっただろうという記憶ベースの書き起こしです）
> ・引数のlistは隣接行列の集合です．
> ・main関数では，1×1の隣接行列だけからなるlistを作って，そのlistを引数としたenumerateをcallすることになります．
> ・隣接行列を用いて疑似コードを書いていますが，実際はすべてコードを使って実現できます．使うメモリを半分にするためです．
> ・このままでは無限ループになる（探索木の左側の枝の子孫を永遠にたどる）ので，
>    適当な深さで止める停止条件が必要になります．
> ・隣接行列の形を制御すれば，順序木だけを生成できること，以前，ある論文で発表しています．
>    それを拡張すれば，無順序木や根なし木にも拡張できるだろうと思っています．
> ・上記とは別に，8, 10行目において，以下のようなフィルタを追加することで，生成するグラフの形を制御することができます．
>      ＊ あるグラフg_sを部分グラフにもつものは，自然界で安定しない化合部のグラフ表現．
>         だから，g(M_i)がg_sを部分グラフとして含むなら，M_iをchildrenOfM1に追加しない．
>         M_iをクエリ，様々なg_sの集合をグラフデータベースとするスーパーグラフ検索問題