How

以前，作ったグラフ列挙アルゴリズムの簡単な疑似コードを書いてみました．
（Javaのプログラムを読み直したわけではなく，たぶんこうだっただろうという記憶ベースの書き起こしです）
・引数のlistは隣接行列の集合です．
・main関数では，1×1の隣接行列だけからなるlistを作って，そのlistを引数としたenumerateをcallすることになります．
・隣接行列を用いて疑似コードを書いていますが，実際はすべてコードを使って実現できます．使うメモリを半分にするためです．
・このままでは無限ループになる（探索木の左側の枝の子孫を永遠にたどる）ので，
   適当な深さで止める停止条件が必要になります．
・隣接行列の形を制御すれば，
順序木だけを生成できること，以前，ある論文で発表しています．
   それを拡張すれば，無順序木や根なし木にも拡張できるだろうと思っています．
・上記とは別に，8, 10行目において，以下のようなフィルタを追加することで，生成するグラフの形を制御することができます．
     ＊ あるグラフg_sを部分グラフにもつものは，自然界で安定しない化合部のグラフ表現．
        だから，g(M_i)がg_sを部分グラフとして含むなら，M_iをchildrenOfM1に追加しない．
        M_iをクエリ，様々なg_sの集合をグラフデータベースとするスーパーグラフ検索問題

・頂点ラベルを扱う場合：main関数において，listに加える隣接行列を頂点ラベルの数にする．
（＝enumerate関数の変更はなし）
・辺ラベルを扱う場合：fの第3引数を1と0だけでなく，ラベルの種類分だけ増やす．


ベースはそうなると思いますが，様々な工夫点が必要になると思います．
例えば
(1)g(M)が連結グラフかどうかのチェックが必要になります．一般的に，連結性のチェックはO(|E(g)|)ですが，
   この問題の場合は，O(1)で実現できます．ある隣接行列Mは，2つの隣接行列の組み合わせでできますが，
   その片方の隣接行列が非連結でかつ，Mを生成したときのfの第3引数が0であれば，g(M)は連結になります．
(2)listは隣接行列の集合と書いていますが，実際はAcGMコードとなるでしょう．
   また，(1)の理由からそのコードが連結かどうかのboolean型の変数をもつクラスを作ることになります．
(3)フィルタについては，以前のメールで言及しましたが，それの配置についても2つ考えられます．
    newM1を作ってみないとフィルタリングできないグラフと，それを作る前にフィルタリングできるグラフがあります．
    後者の例としては，Cは「4本の単結合」「2本の単結合と1本の2重結合」「1本の単結合と1本の3重結合」の
    いずれかをもつことができますが，それはnewM1を作る前にnewM1がそうなりそうかを判定できます．
    そうするとnewM1のインスタンス化を回避でき，作ってみてフィルタリングするよりも計算時間を削減できます．